---
title: 前端面试知识总结
date: 2020-04-14 16:33:54
categories: 
- program
---

# 1、常用全总结

[链接](https://firefly1984982452.github.io/2018/02/28/%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E7%9F%AD%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/)

# 2、基础

## 居中

[居中](https://firefly1984982452.github.io/2018/04/24/%E6%89%8B%E6%9C%BA%E7%AB%AF%E3%80%81%E7%94%B5%E8%84%91%E7%AB%AF%E4%B8%ADCSS%E5%B1%85%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/)

## 数组

[链接](https://firefly1984982452.github.io/2018/05/02/JavaScript%E4%B9%8B%E6%95%B0%E7%BB%84/)

## HTML渲染过程

1、解析HTML，构成DOM
2、解析CSS，形成CSS对象模型
3、将CSS和DOM合并，构成渲染模型
4、绘制

重绘：corlor、borde、visibility，只会小变动；
重排（回流）：DOM操作、CSS属性改变、伪类操作，会大变动。

## 前端路由和后端路由

前端路由（#）：hash值或pushStatu
后端路由（/）：通过URL跳转到具体的html页面，每次跳转都重新访问服务端，服务端返回页面。

## 事件循环（`Event Loop`）、宏任务（`macrotask`）、微任务（`microtask`）

事件循环（`Event Loop`）：执行完宏任务后，将微任务排队添加任务，执行后再循环检查有没有宏任务……所以整个过程称为事件循环。
宏任务（`macrotask`）：主代码、setTimeout、setInterval、setImmediate(IE)、MessageChannel
微任务（`microtask`）：promise、process.nextTick、MutationObserver

执行顺序：先宏任务--》执行结束后--》再执行所有微任务--》渲染--》下一个宏任务

```
console.log('start');

setTimeout(function() {
  console.log('1');
}, 10);

new Promise(resolve => {
    console.log('2');
    resolve();
    setTimeout(() => console.log('3'), 10);
}).then(function() {
    console.log('4')
})

console.log('end');
```

这里的执行顺序就是`start-->2-->end-->4-->1-->3`

**注意**：

```
promise是立即执行的，创建的时候就会执行，不存在将promise推入微任务；
resolve()是表示promise的状态为fullfilled，相当于只是定义了一个有状态的promise，并没有调用它；
promise调用then的前提是promise的状态为fullfilled；
只有promise调用then的时候，then里面的函数才会被推入微任务中。
```
## bind、apply、call

这3个全都是用来重新定义this指向我传入的对象

[学习链接](https://www.runoob.com/w3cnote/js-call-apply-bind.html)

```
var name = '张三';
var age = '24';
var obj = {
    name: this.name, // 此处的this指向window
    objAge: this.age, // 此处的this指向window
    fun: function(){
        console.log(this.name+this.age+this.objAge) // 此处的this指向obj，所以显示'张三undefined 24'
    }
}
```

### 使用方法

```
...
var pd = {
  name: '彭丹',
  age: '18'
}

obj.fun.call(pd); // 彭丹18
obj.fun.apply(pd); // 彭丹18
obj.fun.bind(pd))(); // 彭丹18
```

### 传参

```
...
console.log(this.name+'年龄 '+this.age + ' 来自'+fm+' 去往'+t); // 此处的fm和t就是要传入的参数
...

obj.fun.call(pd,'长沙','上海'); // 彭丹 年龄18 来自长沙 去往上海
obj.fun.apply(pd,['长沙','上海']); // 彭丹 年龄18 来自长沙 去往上海
obj.fun.bind(pd,'长沙','上海')(); // 彭丹 年龄18 来自长沙 去往上海
obj.fun.bind(pd,['长沙','上海'])(); // 彭丹 年龄18 来自长沙上海 去往undefined
```

# 3、性能优化

## 前端优化

[前端优化](https://firefly1984982452.github.io/2018/09/12/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/)

## 移动端优化

- 初次加载缓慢时用骨架屏
- 尽量用v-show而不是v-if
- for循环里面加key值
- 首页可考虑用ssr渲染

## SEO

- vue中的mode使用`‘history’`时地址栏不会有`#`号，利于SEO，但需要后台配合一起设置，否则页面会空白（mode默认是`‘hash’`）。

- 图片和文字添加alt属性。

- body中代码语义化，比如说使用`<header>`、`<footer>`、`<nav>`的标签来代替`<div>`。

- 少使用`iframe`。

- 谨慎使用`display:none`

## 防抖和节流

[可视化在线demo](http://demo.nimius.net/debounce_throttle/)
[滚动栏在线demo](https://wall-wxk.github.io/blogDemo/2017/02/15/throttleAndDebounce.html)

[学习链接1](https://www.jianshu.com/p/f9f6b637fd6c)
[学习链接2](https://www.jianshu.com/p/b73c2acad696)

### 概念

防抖：（停止后才1次）触发事件后n秒内只执行1次，如果n秒内又触发了事件，则会重新计算时间。
节流：（几秒1次）一定时间内只能执行1次。

### 应用场景

防抖：

- 搜索框搜索输入，只有用户停止输入时，才发送请求；
- 手机号、邮箱号验证输入检测；
- 窗口resize，只需等窗口调整完成后计算大小，防止重复渲染。

节流：

- 表单验证时重复点击提交按钮；
- 滚动加载；
- 浏览器搜索框联想功能。

### 实现原理

1、防抖

正常情况下，我希望它多久执行，假设邮箱验证正常情况是每隔1秒向后台发送请求，然后用户一直不停的在输入框输入，此时会不断的清除Timeout，直到停止调用方法1秒后才正常去向后台发送请求。

```
// 防抖【防止多次触发滚动事件】
var time = '';
handleDebounce () {
    console.log('调用')
    // 清除未执行的代码，重置回初始化状态
    if(timer){clearTimeout(timer);} 
    //开始一个新的任务
    timer = setTimeout(()=>{
        console.log('函数防抖');
    }, 1000);
},
```
![image.png](https://wx2.sinaimg.cn/mw690/0069qZtTgy1gho47acnm9j303q03ndfo.jpg)

2、节流

假设浏览器一直在不停滚动，我不可能等停止了再请求，也不可能一直请求。

```
var flag = false;
handleThrottle () {
  console.log('调用')
  if(!flag){return}
  flag = false;
  setTimeout(()=>{
    console.log('函数节流');
    flag = true;
  },1000)
}
```
![image.png](https://wx4.sinaimg.cn/mw690/0069qZtTgy1gho487f7lnj305904omx1.jpg)

# 4、移动端

## 适配问题

- `<meta>`中设置自动伸缩。

- 字体如果需求是小于`12px`的话，可以先设置字体为`20px`，再使用`transfrom:scale(0.5)`进行缩放。（也可以使用图片，但不推荐）

- [其它](https://firefly1984982452.github.io/2018/03/05/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/)

## 适配rem

[适配](https://firefly1984982452.github.io/2018/03/09/%E6%A0%B9%E6%8D%AE%E8%AE%BE%E8%AE%A1%E5%9B%BE%E9%80%82%E9%85%8Dremm/)

# 5、vue

## vue简单的双向绑定原理

```
<div id="div"></div>
<input type="text" name="" id="test" value="" />
  <script>
  var obj = {}
  Object.defineProperty(obj,'age',{
    get:function() {console.log('get')},
    set:function(newValue) {
      document.getElementById('test').value = newValue
      document.getElementById('div').innerHTML = newValue
    }
  })
  document.addEventListener('input',(e)=> {
    obj.age = e.target.value
  })
  </script>
```

## v-if与v-show

`v-if`：整个元素删除；适用于条件少变动时。
`v-show`：用`display:none`；适用于频繁切换。
**eCharts中要使用v-if**

## axios promise async

axios支持并发请求的接口、支持promise；
async避免回调地狱，基于promise实现；
promise的三种状态：进行中、成功、失败。

## vue部分总结

[链接](https://firefly1984982452.github.io/2018/03/19/vue%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/)

# 6、数据库

[基本增删改查](https://firefly1984982452.github.io/2019/04/17/sql%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/)

# 7、ES6

[链接](https://firefly1984982452.github.io/2019/10/16/ES6%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93/)

# 8、HTTP

## 协议

客户端和服务器之间传输数据的规范，全称是“超文本传输协议”。

## 协议请求

GET、POST和OPTION

## GET和POST的区别

- GET产生1个TCP数据包，POST产生2个TCP数据包（GET请求会把header和data一并发出去，POST会先发header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok）
- GET参数直接显示在地址栏，不能传输敏感信息
- GET请求的地址可以收藏
- GET请求会被主动缓存
- GET请求参数会被保留在浏览记录中
- GET请求参数有长度限制（不同浏览器不同限制）
- GET只能URL传参

## HTTP和HTTPS的区别

- HTTPS=HTTP+SSL证书

- HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密协议传输

## 跨域

[更全跨域方法链接](https://segmentfault.com/a/1190000011145364)

- jsonp跨域
- 跨域资源共享（CORS）
- nodejs中间件代理跨域
- iframe

## jsonp

把JS、CSS、IMG等静态资源分离到独立域名的服务器上。
**缺点：只能实现GET请求**。

### 原生实现

```
<script>
  var script = document.createElement('script');
  script.type = 'text/javascript';

  // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
  script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
  document.head.appendChild(script);

  // 回调执行函数
  function handleCallback(res) {
      alert(JSON.stringify(res));
  }
</script>
```

 ### jquery ajax

```
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {}
});
```

### vue.js：

```
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```
## CORS

普通跨域请求，只需要服务端设置`Access-Control-Allow-Origin`即可；若要携带`cookie`请求，前后端都要设置。

### 原生ajax

```
// 前端设置是否带cookie
xhr.withCredentials = true;
```

### jQuery ajax

```
$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});
```

### vue框架 axios设置

```
axios.defaults.withCredentials = true
```
### Nodejs中间件代理跨域

如`proxy`中间件

## 缓存

一般是在`html`中的`meta`标签上定义属性

方法一：

```
<meta http-equiv="Pragma" content="no-cache">
```

方法二：

```
<meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT">
```

请求--判断max-age是否过期（没过期就直接在缓存数据库中得到数据）--过期后判断属性是否字段一致，再使用缓存。

## session和cookie

cookie是在客户端，session是在服务端。
一般如果想跳过cookie的限制，就用session。

# 9、原型

constructor
instanceof
prototype
typeof

## 构造函数

构造函数：一个普通的函数，内部用this来构造属性和方法。

```
function Cat(name) {
  this.name = name
}
```
或者：
```
var obj = new Object()
===
var obj = {}
```
也就是我们平时直接用的Object类型(引用类型)

基本类型指向不一样

```
var s1 = new String('s');
var s2 = 's'
s1 == s2; // true
s1 === s2; // false
s1的原型是object，s2的原型是string
```
所以，obj自动含有一个`constructor`属性指向他们的构造函数。

```
obj.constructor === Object
```

javascript还提供一个`instanceof`运算符来验证对象和实例对象之间的关系。

```
obj instanceof Object
```

## prototype属性

```
var s1 = 'a';
var s2 = 'b';
String.prototype.age = 12;
此时：
s1.age //12
s2.age //12
现在改变s1的age属性
s1.age = 33 // 33
发现s2的age属性并没有跟着改变
s2.age // 12
```

`prototype`就是所有的实例共享的，不用写在构造函数里面的，只要更改了它，所有的实例对象都会受影响。

`Array.prototype` === `arr.__proto__`

比如`var arr = [1,2]; arr.push(3)`，这里的arr能直接使用数组的push方法，如果数组原型想使用push方法只能使用`Array.prototype.push()`。

例子：

合并两个数组，而不是用concat合并并创建新数组。

```
var arr1 = [1,2,3];
var arr2 = [4,5,6];
Array.prototype.push.apply(arr1,arr2); 或 arr1.push.push.apply(arr1,arr2);
arr1; // [1, 2, 3, 4, 5, 6]
```


# 10、CSS

## 清除浮动

1、使用空元素clear:both
2、overflow:hidden
3、使用邻近元素clear:both
4、使用伪类:before元素clear:both

## 左边定宽，右边自适应

1、使用flex
2、右边的width: calc(100% - 100px)
3、使用float

## BFC

BFC是特性（功能），不是定义。

比如float，position、absolute

# 11、与JAVA相通的概念

## MVC、MVVM

### MVC

Model层:模型层，比如图片放一个类，标题放一个类
View层：显示页面，如xml
Controller层：控制Model的读取、存储。如MainActivity

## MVVM

MVVM实现了View和Model的自动同步，当Model的属性改变时，我们不再手动操作DOM，也就是双向绑定。

Model层：后端传递的数据
View层：页面
ViewModel层：视图模型，连接Model和View的桥梁。将Model转为View（将后端数据显示给前端）用的是数据绑定，将View转为Model（将前端数据转给后端）用的DOM监听，这种实现方法称为为**数据的双向绑定**。

## 类

js里面的类和其它OOP里面的类概念是一样的。（比如，所有的车是一个类，房子是一个类）

## jsBridge

js与android的通信

### android代码：

java发消息给js：
`webview.send()`
java收js的消息
`webview.registerHander('name',new Bridge(){})`


### javaScript代码：

js发消息给java
`window.WebViewJavaScriptBridge.send()`
js收java的消息
`document.addEventListener('WebViewJavaScriptBridgeReady',()=>{})`
