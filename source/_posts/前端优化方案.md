---
title: 前端优化方案
date: 2018-09-12 15:19:56
categories: 
- program
---

# 计算页面加载完成所需要的总时间

`performance.timing.loadEventEnd - performance.timing.navigationStart`

# 小图标使用sprite图
```
background: url(xxx) no-repeat;
width: 64px;
height: 64px;
background-position: 0 -64px;
```
# 减少重绘和回流

- 回流
改变尺寸或布局，如`px`、`width`、`height`、`border`、`margin`、`padding`等

- 重绘
改变外观或风格，如`color`

如何减少：

- 不要操作`'px'`,可以切换`class`；
- 不要经常访问元素的`'px'`,可以将`'px'`保存起来操作；
- 先将元素`display:none`,改完之后再`display:block`；
- 使用`resize`和`scroll`时进行`防抖`和`节流`处理，这两者会直接导致`回流`；

# 异步网络请求

Promise

# 减少HTTP请求

请求之后也可以存储下来

# 使用公用方法

比如有时间戳转时间的插件的话，写一个即可，不用每个页面都写

# 使用公用组件

比如公用的头部尾部等组件

# 使用压缩JS和压缩CSS文件


## SEO

- vue中的mode使用`‘history’`时地址栏不会有`#`号，利于SEO，但需要后台配合一起设置，否则页面会空白（mode默认是`‘hash’`）。

- 图片和文字添加alt属性。

- body中代码语义化，比如说使用`<header>`、`<footer>`、`<nav>`的标签来代替`<div>`。

- 少使用`iframe`。

- 谨慎使用`display:none`

## 移动端优化

- 初次加载缓慢时用骨架屏
- 尽量用v-show而不是v-if
- for循环里面加key值
- 首页可考虑用ssr渲染

# WebWorker

大量DOM操作时使用WebWorker

# requestAnimationFrame

染几万条数据并不卡住界面

## 普通用法

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      控件
    </ul>
    <script>
      console.time("createElement");
      // 插入十万条数据
      const total = 100000;
      let ul = document.querySelector("ul");
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < total; i++) {
        const li = document.createElement("li");
        li.innerText = Math.floor(Math.random()*total);
        fragment.appendChild(li);
      }
      ul.appendChild(fragment);
      console.timeEnd("createElement");
    </script>
  </body>
</html>

```

## 使用requestAnimationFrame

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      控件
    </ul>
    <script>
      setTimeout(() => {
      // 插入十万条数据
      const total = 100000;
      const once = 20;
      const loopCount = total / once;
      let countOfRender = 0;
      let ul = document.querySelector('ul');
      function add () {
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < once; i++) {
          const li = document.createElement("li");
          li.innerText = Math.floor(Math.random()*total);
          fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
      }
      function loop(){
        if(countOfRender < loopCount) {
          requestAnimationFrame(add);
        }
      }
      loop();
      }, 0);
    </script>
  </body>
</html>

```

# Page Visibility API